/* automatically generated by rust-bindgen 0.62.0 */

#[doc = " DictionaryInfo structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_dictionary_info_t {
    #[doc = " filename of dictionary"]
    #[doc = " On Windows, filename is stored in UTF-8 encoding"]
    pub filename: *const ::std::os::raw::c_char,
    #[doc = " character set of the dictionary. e.g., \"SHIFT-JIS\", \"UTF-8\""]
    pub charset: *const ::std::os::raw::c_char,
    #[doc = " How many words are registered in this dictionary."]
    pub size: ::std::os::raw::c_uint,
    #[doc = " dictionary type"]
    #[doc = " this value should be MECAB_USR_DIC, MECAB_SYS_DIC, or MECAB_UNK_DIC."]
    pub type_: ::std::os::raw::c_int,
    #[doc = " left attributes size"]
    pub lsize: ::std::os::raw::c_uint,
    #[doc = " right attributes size"]
    pub rsize: ::std::os::raw::c_uint,
    #[doc = " version of this dictionary"]
    pub version: ::std::os::raw::c_ushort,
    #[doc = " pointer to the next dictionary info."]
    pub next: *mut mecab_dictionary_info_t,
}
#[test]
fn bindgen_test_layout_mecab_dictionary_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<mecab_dictionary_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mecab_dictionary_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(mecab_dictionary_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mecab_dictionary_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mecab_dictionary_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_dictionary_info_t),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).charset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_dictionary_info_t),
            "::",
            stringify!(charset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_dictionary_info_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_dictionary_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_dictionary_info_t),
            "::",
            stringify!(lsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_dictionary_info_t),
            "::",
            stringify!(rsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_dictionary_info_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_dictionary_info_t),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Path structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_path_t {
    #[doc = " pointer to the right node"]
    pub rnode: *mut mecab_node_t,
    #[doc = " pointer to the next right path"]
    pub rnext: *mut mecab_path_t,
    #[doc = " pointer to the left node"]
    pub lnode: *mut mecab_node_t,
    #[doc = " pointer to the next left path"]
    pub lnext: *mut mecab_path_t,
    #[doc = " local cost"]
    pub cost: ::std::os::raw::c_int,
    #[doc = " marginal probability"]
    pub prob: f32,
}
#[test]
fn bindgen_test_layout_mecab_path_t() {
    const UNINIT: ::std::mem::MaybeUninit<mecab_path_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mecab_path_t>(),
        40usize,
        concat!("Size of: ", stringify!(mecab_path_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mecab_path_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mecab_path_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rnode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_path_t),
            "::",
            stringify!(rnode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rnext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_path_t),
            "::",
            stringify!(rnext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lnode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_path_t),
            "::",
            stringify!(lnode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lnext) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_path_t),
            "::",
            stringify!(lnext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cost) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_path_t),
            "::",
            stringify!(cost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prob) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_path_t),
            "::",
            stringify!(prob)
        )
    );
}
#[doc = " Node structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_node_t {
    #[doc = " pointer to the previous node."]
    pub prev: *mut mecab_node_t,
    #[doc = " pointer to the next node."]
    pub next: *mut mecab_node_t,
    #[doc = " pointer to the node which ends at the same position."]
    pub enext: *mut mecab_node_t,
    #[doc = " pointer to the node which starts at the same position."]
    pub bnext: *mut mecab_node_t,
    #[doc = " pointer to the right path."]
    #[doc = " this value is NULL if MECAB_ONE_BEST mode."]
    pub rpath: *mut mecab_path_t,
    #[doc = " pointer to the right path."]
    #[doc = " this value is NULL if MECAB_ONE_BEST mode."]
    pub lpath: *mut mecab_path_t,
    #[doc = " surface string."]
    #[doc = " this value is not 0 terminated."]
    #[doc = " You can get the length with length/rlength members."]
    pub surface: *const ::std::os::raw::c_char,
    #[doc = " feature string"]
    pub feature: *const ::std::os::raw::c_char,
    #[doc = " unique node id"]
    pub id: ::std::os::raw::c_uint,
    #[doc = " length of the surface form."]
    pub length: ::std::os::raw::c_ushort,
    #[doc = " length of the surface form including white space before the morph."]
    pub rlength: ::std::os::raw::c_ushort,
    #[doc = " right attribute id"]
    pub rcAttr: ::std::os::raw::c_ushort,
    #[doc = " left attribute id"]
    pub lcAttr: ::std::os::raw::c_ushort,
    #[doc = " unique part of speech id. This value is defined in \"pos.def\" file."]
    pub posid: ::std::os::raw::c_ushort,
    #[doc = " character type"]
    pub char_type: ::std::os::raw::c_uchar,
    #[doc = " status of this model."]
    #[doc = " This value is MECAB_NOR_NODE, MECAB_UNK_NODE, MECAB_BOS_NODE, MECAB_EOS_NODE, or MECAB_EON_NODE."]
    pub stat: ::std::os::raw::c_uchar,
    #[doc = " set 1 if this node is best node."]
    pub isbest: ::std::os::raw::c_uchar,
    #[doc = " forward accumulative log summation."]
    #[doc = " This value is only available when MECAB_MARGINAL_PROB is passed."]
    pub alpha: f32,
    #[doc = " backward accumulative log summation."]
    #[doc = " This value is only available when MECAB_MARGINAL_PROB is passed."]
    pub beta: f32,
    #[doc = " marginal probability."]
    #[doc = " This value is only available when MECAB_MARGINAL_PROB is passed."]
    pub prob: f32,
    #[doc = " word cost."]
    pub wcost: ::std::os::raw::c_short,
    #[doc = " best accumulative cost from bos node to this node."]
    pub cost: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_mecab_node_t() {
    const UNINIT: ::std::mem::MaybeUninit<mecab_node_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mecab_node_t>(),
        104usize,
        concat!("Size of: ", stringify!(mecab_node_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mecab_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mecab_node_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(enext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bnext) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(bnext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rpath) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(rpath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpath) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(lpath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).surface) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feature) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(feature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlength) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(rlength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcAttr) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(rcAttr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lcAttr) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(lcAttr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).posid) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(posid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).char_type) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(char_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isbest) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(isbest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beta) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(beta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prob) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(prob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wcost) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(wcost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cost) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(mecab_node_t),
            "::",
            stringify!(cost)
        )
    );
}
pub const MECAB_NOR_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_NOR_NODE;
pub const MECAB_UNK_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_UNK_NODE;
pub const MECAB_BOS_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_BOS_NODE;
pub const MECAB_EOS_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_EOS_NODE;
pub const MECAB_EON_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_EON_NODE;
#[repr(i32)]
#[doc = " Parameters for MeCab::Node::stat"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    #[doc = " Normal node defined in the dictionary."]
    MECAB_NOR_NODE = 0,
    #[doc = " Unknown node not defined in the dictionary."]
    MECAB_UNK_NODE = 1,
    #[doc = " Virtual node representing a beginning of the sentence."]
    MECAB_BOS_NODE = 2,
    #[doc = " Virtual node representing a end of the sentence."]
    MECAB_EOS_NODE = 3,
    #[doc = " Virtual node representing a end of the N-best enumeration."]
    MECAB_EON_NODE = 4,
}
pub const MECAB_SYS_DIC: _bindgen_ty_2 = _bindgen_ty_2::MECAB_SYS_DIC;
pub const MECAB_USR_DIC: _bindgen_ty_2 = _bindgen_ty_2::MECAB_USR_DIC;
pub const MECAB_UNK_DIC: _bindgen_ty_2 = _bindgen_ty_2::MECAB_UNK_DIC;
#[repr(i32)]
#[doc = " Parameters for MeCab::DictionaryInfo::type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    #[doc = " This is a system dictionary."]
    MECAB_SYS_DIC = 0,
    #[doc = " This is a user dictionary."]
    MECAB_USR_DIC = 1,
    #[doc = " This is a unknown word dictionary."]
    MECAB_UNK_DIC = 2,
}
pub const MECAB_ONE_BEST: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ONE_BEST;
pub const MECAB_NBEST: _bindgen_ty_3 = _bindgen_ty_3::MECAB_NBEST;
pub const MECAB_PARTIAL: _bindgen_ty_3 = _bindgen_ty_3::MECAB_PARTIAL;
pub const MECAB_MARGINAL_PROB: _bindgen_ty_3 = _bindgen_ty_3::MECAB_MARGINAL_PROB;
pub const MECAB_ALTERNATIVE: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ALTERNATIVE;
pub const MECAB_ALL_MORPHS: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ALL_MORPHS;
pub const MECAB_ALLOCATE_SENTENCE: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ALLOCATE_SENTENCE;
#[repr(i32)]
#[doc = " Parameters for MeCab::Lattice::request_type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    #[doc = " One best result is obtained (default mode)"]
    MECAB_ONE_BEST = 1,
    #[doc = " Set this flag if you want to obtain N best results."]
    MECAB_NBEST = 2,
    #[doc = " Set this flag if you want to enable a partial parsing mode."]
    #[doc = " When this flag is set, the input |sentence| needs to be written"]
    #[doc = " in partial parsing format."]
    MECAB_PARTIAL = 4,
    #[doc = " Set this flag if you want to obtain marginal probabilities."]
    #[doc = " Marginal probability is set in MeCab::Node::prob."]
    #[doc = " The parsing speed will get 3-5 times slower than the default mode."]
    MECAB_MARGINAL_PROB = 8,
    #[doc = " Set this flag if you want to obtain alternative results."]
    #[doc = " Not implemented."]
    MECAB_ALTERNATIVE = 16,
    #[doc = " When this flag is set, the result linked-list (Node::next/prev)"]
    #[doc = " traverses all nodes in the lattice."]
    MECAB_ALL_MORPHS = 32,
    #[doc = " When this flag is set, tagger internally copies the body of passed"]
    #[doc = " sentence into internal buffer."]
    MECAB_ALLOCATE_SENTENCE = 64,
}
pub const MECAB_ANY_BOUNDARY: _bindgen_ty_4 = _bindgen_ty_4::MECAB_ANY_BOUNDARY;
pub const MECAB_TOKEN_BOUNDARY: _bindgen_ty_4 = _bindgen_ty_4::MECAB_TOKEN_BOUNDARY;
pub const MECAB_INSIDE_TOKEN: _bindgen_ty_4 = _bindgen_ty_4::MECAB_INSIDE_TOKEN;
#[repr(i32)]
#[doc = " Parameters for MeCab::Lattice::boundary_constraint_type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    #[doc = " The token boundary is not specified."]
    MECAB_ANY_BOUNDARY = 0,
    #[doc = " The position is a strong token boundary."]
    MECAB_TOKEN_BOUNDARY = 1,
    #[doc = " The position is not a token boundary."]
    MECAB_INSIDE_TOKEN = 2,
}
#[doc = " DictionaryInfo structure"]
pub type MeCab_DictionaryInfo = mecab_dictionary_info_t;
#[doc = " Path structure"]
pub type MeCab_Path = mecab_path_t;
#[doc = " Node structure"]
pub type MeCab_Node = mecab_node_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MeCab_Allocator {
    pub _address: u8,
}
#[repr(C)]
pub struct MeCab_Lattice__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Lattice class"]
#[repr(C)]
#[derive(Debug)]
pub struct MeCab_Lattice {
    pub vtable_: *const MeCab_Lattice__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_MeCab_Lattice() {
    assert_eq!(
        ::std::mem::size_of::<MeCab_Lattice>(),
        8usize,
        concat!("Size of: ", stringify!(MeCab_Lattice))
    );
    assert_eq!(
        ::std::mem::align_of::<MeCab_Lattice>(),
        8usize,
        concat!("Alignment of ", stringify!(MeCab_Lattice))
    );
}
extern "C" {
    #[doc = " Create new Lattice object"]
    #[doc = " @return new Lattice object"]
    #[link_name = "\u{1}?create@Lattice@MeCab@@SAPEAV12@XZ"]
    pub fn MeCab_Lattice_create() -> *mut MeCab_Lattice;
}
impl MeCab_Lattice {
    #[inline]
    pub unsafe fn create() -> *mut MeCab_Lattice {
        unsafe { MeCab_Lattice_create() }
    }
}
#[repr(C)]
pub struct MeCab_Model__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Model class"]
#[repr(C)]
#[derive(Debug)]
pub struct MeCab_Model {
    pub vtable_: *const MeCab_Model__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_MeCab_Model() {
    assert_eq!(
        ::std::mem::size_of::<MeCab_Model>(),
        8usize,
        concat!("Size of: ", stringify!(MeCab_Model))
    );
    assert_eq!(
        ::std::mem::align_of::<MeCab_Model>(),
        8usize,
        concat!("Alignment of ", stringify!(MeCab_Model))
    );
}
extern "C" {
    #[doc = " Return a version string"]
    #[doc = " @return version string"]
    #[link_name = "\u{1}?version@Model@MeCab@@SAPEBDXZ"]
    pub fn MeCab_Model_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Factory method to create a new Model with a specified main's argc/argv-style parameters."]
    #[doc = " Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the"]
    #[doc = " cause of the errors."]
    #[doc = " @return new Model object"]
    #[doc = " @param argc number of parameters"]
    #[doc = " @param argv parameter list"]
    #[link_name = "\u{1}?create@Model@MeCab@@SAPEAV12@HPEAPEAD@Z"]
    pub fn MeCab_Model_create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Model;
}
extern "C" {
    #[doc = " Factory method to create a new Model with a string parameter representation, i.e.,"]
    #[doc = " \"-d /user/local/mecab/dic/ipadic -Ochasen\"."]
    #[doc = " Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the"]
    #[doc = " cause of the errors."]
    #[doc = " @return new Model object"]
    #[doc = " @param arg single string representation of the argment."]
    #[link_name = "\u{1}?create@Model@MeCab@@SAPEAV12@PEBD@Z"]
    pub fn MeCab_Model_create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Model;
}
impl MeCab_Model {
    #[inline]
    pub unsafe fn version() -> *const ::std::os::raw::c_char {
        unsafe { MeCab_Model_version() }
    }
    #[inline]
    pub unsafe fn create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Model {
        unsafe { MeCab_Model_create(argc, argv) }
    }
    #[inline]
    pub unsafe fn create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Model {
        unsafe { MeCab_Model_create1(arg) }
    }
}
#[repr(C)]
pub struct MeCab_Tagger__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Tagger class"]
#[repr(C)]
#[derive(Debug)]
pub struct MeCab_Tagger {
    pub vtable_: *const MeCab_Tagger__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_MeCab_Tagger() {
    assert_eq!(
        ::std::mem::size_of::<MeCab_Tagger>(),
        8usize,
        concat!("Size of: ", stringify!(MeCab_Tagger))
    );
    assert_eq!(
        ::std::mem::align_of::<MeCab_Tagger>(),
        8usize,
        concat!("Alignment of ", stringify!(MeCab_Tagger))
    );
}
extern "C" {
    #[doc = " Handy static method."]
    #[doc = " Return true if lattice is parsed successfully."]
    #[doc = " This function is equivalent to"]
    #[doc = " {"]
    #[doc = "   Tagger *tagger = model.createModel();"]
    #[doc = "   cosnt bool result = tagger->parse(lattice);"]
    #[doc = "   delete tagger;"]
    #[doc = "   return result;"]
    #[doc = " }"]
    #[doc = " @return boolean"]
    #[link_name = "\u{1}?parse@Tagger@MeCab@@SA_NAEBVModel@2@PEAVLattice@2@@Z"]
    pub fn MeCab_Tagger_parse(model: *const MeCab_Model, lattice: *mut MeCab_Lattice) -> bool;
}
extern "C" {
    #[doc = " Factory method to create a new Tagger with a specified main's argc/argv-style parameters."]
    #[doc = " Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the"]
    #[doc = " cause of the errors."]
    #[doc = " @return new Tagger object"]
    #[doc = " @param argc number of parameters"]
    #[doc = " @param argv parameter list"]
    #[link_name = "\u{1}?create@Tagger@MeCab@@SAPEAV12@HPEAPEAD@Z"]
    pub fn MeCab_Tagger_create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Tagger;
}
extern "C" {
    #[doc = " Factory method to create a new Tagger with a string parameter representation, i.e.,"]
    #[doc = " \"-d /user/local/mecab/dic/ipadic -Ochasen\"."]
    #[doc = " Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the"]
    #[doc = " cause of the errors."]
    #[doc = " @return new Model object"]
    #[doc = " @param arg single string representation of the argment."]
    #[link_name = "\u{1}?create@Tagger@MeCab@@SAPEAV12@PEBD@Z"]
    pub fn MeCab_Tagger_create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Tagger;
}
extern "C" {
    #[doc = " Return a version string"]
    #[doc = " @return version string"]
    #[link_name = "\u{1}?version@Tagger@MeCab@@SAPEBDXZ"]
    pub fn MeCab_Tagger_version() -> *const ::std::os::raw::c_char;
}
impl MeCab_Tagger {
    #[inline]
    pub unsafe fn parse(model: *const MeCab_Model, lattice: *mut MeCab_Lattice) -> bool {
        unsafe { MeCab_Tagger_parse(model, lattice) }
    }
    #[inline]
    pub unsafe fn create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Tagger {
        unsafe { MeCab_Tagger_create(argc, argv) }
    }
    #[inline]
    pub unsafe fn create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Tagger {
        unsafe { MeCab_Tagger_create1(arg) }
    }
    #[inline]
    pub unsafe fn version() -> *const ::std::os::raw::c_char {
        unsafe { MeCab_Tagger_version() }
    }
}
extern "C" {
    #[doc = " Alias of Lattice::create()"]
    #[link_name = "\u{1}?createLattice@MeCab@@YAPEAVLattice@1@XZ"]
    pub fn MeCab_createLattice() -> *mut MeCab_Lattice;
}
extern "C" {
    #[doc = " Alias of Mode::create(argc, argv)"]
    #[link_name = "\u{1}?createModel@MeCab@@YAPEAVModel@1@HPEAPEAD@Z"]
    pub fn MeCab_createModel(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Model;
}
extern "C" {
    #[doc = " Alias of Mode::create(arg)"]
    #[link_name = "\u{1}?createModel@MeCab@@YAPEAVModel@1@PEBD@Z"]
    pub fn MeCab_createModel1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Model;
}
extern "C" {
    #[doc = " Alias of Tagger::create(argc, argv)"]
    #[link_name = "\u{1}?createTagger@MeCab@@YAPEAVTagger@1@HPEAPEAD@Z"]
    pub fn MeCab_createTagger(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Tagger;
}
extern "C" {
    #[doc = " Alias of Tagger::create(arg)"]
    #[link_name = "\u{1}?createTagger@MeCab@@YAPEAVTagger@1@PEBD@Z"]
    pub fn MeCab_createTagger1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Tagger;
}
extern "C" {
    #[doc = " delete Lattice object."]
    #[doc = " This method calles \"delete lattice\"."]
    #[doc = " In some environment, e.g., MS-Windows, an object allocated inside a DLL must be deleted in the same DLL too."]
    #[doc = " @param lattice lattice object"]
    #[link_name = "\u{1}?deleteLattice@MeCab@@YAXPEAVLattice@1@@Z"]
    pub fn MeCab_deleteLattice(lattice: *mut MeCab_Lattice);
}
extern "C" {
    #[doc = " delete Model object."]
    #[doc = " This method calles \"delete model\"."]
    #[doc = " In some environment, e.g., MS-Windows, an object allocated inside a DLL must be deleted in the same DLL too."]
    #[doc = " @param model model object"]
    #[link_name = "\u{1}?deleteModel@MeCab@@YAXPEAVModel@1@@Z"]
    pub fn MeCab_deleteModel(model: *mut MeCab_Model);
}
extern "C" {
    #[doc = " delete Tagger object."]
    #[doc = " This method calles \"delete tagger\"."]
    #[doc = " In some environment, e.g., MS-Windows, an object allocated inside a DLL must be deleted in the same DLL too."]
    #[doc = " @param tagger tagger object"]
    #[link_name = "\u{1}?deleteTagger@MeCab@@YAXPEAVTagger@1@@Z"]
    pub fn MeCab_deleteTagger(tagger: *mut MeCab_Tagger);
}
extern "C" {
    #[doc = " Return last error string."]
    #[doc = " @return error string"]
    #[link_name = "\u{1}?getLastError@MeCab@@YAPEBDXZ"]
    pub fn MeCab_getLastError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " An alias of getLastError."]
    #[doc = " It is kept for backward compatibility."]
    #[doc = " @return error string"]
    #[link_name = "\u{1}?getTaggerError@MeCab@@YAPEBDXZ"]
    pub fn MeCab_getTaggerError() -> *const ::std::os::raw::c_char;
}
